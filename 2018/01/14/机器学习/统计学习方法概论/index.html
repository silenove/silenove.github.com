<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-EN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.2" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.2">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.2" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.0.2',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="统计学习,概论," />


<meta name="description" content="统计学习方法概论 1. 统计学习 1.1. 对象及方法 （1）统计学习的对象：数据 （2）关于数据的基本假设：同类数据具有一定的统计规律性 （3）统计学习的方法：基于数据构建统计模型从而对数据进行预测与分析 （4）组成：监督学习，非监督学习，半监督学习，强化学习 （5）统计学习方法三要素：模型，策略，算法 1.2. 步骤 统计学习方法的步骤：  得到一个有限的训练数据集合； 确定包含所有可能的模型">
<meta name="keywords" content="统计学习,概论">
<meta property="og:type" content="article">
<meta property="og:title" content="统计学习方法概论">
<meta property="og:url" content="http://yoursite.com/2018/01/14/机器学习/统计学习方法概论/index.html">
<meta property="og:site_name" content="silenove blogs">
<meta property="og:description" content="统计学习方法概论 1. 统计学习 1.1. 对象及方法 （1）统计学习的对象：数据 （2）关于数据的基本假设：同类数据具有一定的统计规律性 （3）统计学习的方法：基于数据构建统计模型从而对数据进行预测与分析 （4）组成：监督学习，非监督学习，半监督学习，强化学习 （5）统计学习方法三要素：模型，策略，算法 1.2. 步骤 统计学习方法的步骤：  得到一个有限的训练数据集合； 确定包含所有可能的模型">
<meta property="og:locale" content="zh-EN">
<meta property="og:image" content="http://p35icynkw.bkt.clouddn.com/屏幕快照%202018-01-27%20上午10.02.52.png">
<meta property="og:image" content="http://p35icynkw.bkt.clouddn.com/屏幕快照%202018-01-27%20上午10.04.51.png">
<meta property="og:image" content="http://p35icynkw.bkt.clouddn.com/屏幕快照%202018-01-28%20下午3.21.38.png">
<meta property="og:image" content="http://p35icynkw.bkt.clouddn.com/屏幕快照%202018-01-28%20下午3.37.38.png">
<meta property="og:image" content="http://p35icynkw.bkt.clouddn.com/屏幕快照%202018-01-28%20下午3.42.58.png">
<meta property="og:updated_time" content="2018-01-28T11:12:11.832Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="统计学习方法概论">
<meta name="twitter:description" content="统计学习方法概论 1. 统计学习 1.1. 对象及方法 （1）统计学习的对象：数据 （2）关于数据的基本假设：同类数据具有一定的统计规律性 （3）统计学习的方法：基于数据构建统计模型从而对数据进行预测与分析 （4）组成：监督学习，非监督学习，半监督学习，强化学习 （5）统计学习方法三要素：模型，策略，算法 1.2. 步骤 统计学习方法的步骤：  得到一个有限的训练数据集合； 确定包含所有可能的模型">
<meta name="twitter:image" content="http://p35icynkw.bkt.clouddn.com/屏幕快照%202018-01-27%20上午10.02.52.png">






  <link rel="canonical" href="http://yoursite.com/2018/01/14/机器学习/统计学习方法概论/"/>


  <title>统计学习方法概论 | silenove blogs</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-EN">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">silenove blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">沿路旅程如歌褪变</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/14/机器学习/统计学习方法概论/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="silen Zhou">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="silenove blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">统计学习方法概论</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-14T10:01:30+08:00">2018-01-14</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="统计学习方法概论">统计学习方法概论</h1>
<h2 id="统计学习">1. 统计学习</h2>
<h3 id="对象及方法">1.1. 对象及方法</h3>
<p>（1）统计学习的对象：数据<br>
（2）关于数据的基本假设：同类数据具有一定的统计规律性<br>
（3）统计学习的方法：基于数据构建统计模型从而对数据进行预测与分析<br>
（4）组成：监督学习，非监督学习，半监督学习，强化学习<br>
（5）统计学习方法三要素：模型，策略，算法</p>
<h3 id="步骤">1.2. 步骤</h3>
<p>统计学习方法的步骤：</p>
<ol style="list-style-type: decimal">
<li>得到一个有限的训练数据集合；</li>
<li>确定包含所有可能的模型的假设空间，即学习模型的集合；</li>
<li>确定模型选择的准则，即学习的策略；</li>
<li>实现求解最优模型的算法，即学习的算法；</li>
<li>通过学习方法选择最优的模型；</li>
<li>利用学习的最优模型对新数据进行预测和分析。</li>
</ol>
<h2 id="监督学习">2. 监督学习</h2>
<h3 id="基本概念">2.1. 基本概念</h3>
<p><strong>（1）输入空间、特征空间和输出空间</strong> 将输入与输出所有可能取值的集合分别称为输入空间（input space）和输出空间（output space）。 每个具体的输入是一个实例，通常由特征向量表示，所有特征向量存在的空间成为特征空间（feature space）。</p>
<p><strong>（2）联合概率分布</strong> 监督学习假设输入与输出的随机变量X和Y遵循联合概率分布P(X,Y)，训练数据和测试数据被看作是依联合概率分布P(X,Y)独立同分布产生的。X和Y具有联合概率分布的建设就是监督学习关于数据的基本假设。</p>
<p><strong>（3）假设空间（hypothesis space）</strong> 监督学习的目的在于学习一个由输入到输出的映射，这一映射由模型来表示。模型属于由输入空间到输出空间的映射的集合，这个集合就是假设空间。</p>
<p><strong>（4）广泛使用的分类器</strong> 包括：人工神经网络、支持向量机、高斯混合模型、朴素贝叶斯、决策树和径向基函数分类。</p>
<h2 id="统计学习三要素">3. 统计学习三要素</h2>
<p>统计学习方法由三要素构成：方法 = 模型 + 策略 + 算法</p>
<h3 id="模型">3.1. 模型</h3>
<p>在监督学习过程中，模型就是所要学习的条件概率分布或决策函数。模型的假设空间包含所有可能的条件概率分布或决策函数。</p>
<p><strong>（1）决策函数</strong> 假设空间可以用F表示，假设空间可以定义为决策函数的集合： <span class="math display">\[F=\{f|Y=f(X)\}\]</span> X和Y是定义在输入空间X和输出空间Y上的变量，F通常是一个由参数向量决定的函数族： <span class="math display">\[F=\{f|Y=f_\theta(X),\theta\in R^n\}\]</span> 参数向量$<span class="math inline">\(取值于n维欧式空间\)</span>R^n$，成为参数空间（parameter space）。</p>
<p><strong>（2）条件概率分布</strong> 假设空间定义为条件概率的集合：<br>
<span class="math display">\[F=\{P|P(Y|X)\}\]</span> X和Y是定义在输入空间X和输出空间Y上的随机变量，这时F通常是由一个参数向量决定的条件概率分布族：<br>
<span class="math display">\[F=\{P|P_\theta (Y|X),\theta \in R^n\}\]</span> 参数向量$<span class="math inline">\(取值于n维欧式空间\)</span>R^n$，也成为参数空间。<br>
由决策函数表示的模型为非概率模型，有条件概率表示的模型为概率模型。</p>
<h3 id="策略">3.2. 策略</h3>
<p><strong>（1）损失函数和风险函数（loss function）</strong> 损失函数度量模型一次预测的好坏，风险函数度量平均意义下模型预测的好坏。<br>
损失函数是<span class="math inline">\(f(X)\)</span>和<span class="math inline">\(Y\)</span>的非负实值函数，记作<span class="math inline">\(L(Y,f(X))\)</span>。<br>
（i）0-1损失函数（0-1 loss function） <span class="math display">\[L(Y,f(X))=\left\{
\begin{aligned}
1, \quad Y \neq f(X) \\
0, \quad Y = f(X) \\
\end{aligned}
\right.\]</span></p>
<p>（ii）平方损失函数（quadratic loss function） <span class="math display">\[L(Y,f(x))=(Y-f(X))^2\]</span></p>
<p>（iii）绝对损失函数（absolute loss function） <span class="math display">\[L(Y,f(X))=|Y-f(X)|\]</span></p>
<p>（iiii）对数损失函数（logarithmic loss function） <span class="math display">\[L(Y,P(Y|X))=-logP(Y|X)\]</span></p>
<p>损失函数值越小，模型越好，模型输入、输出(X,Y)遵循联合分布P(X,Y)，损失的期望为：<br>
<span class="math display">\[R_{exp}(f)=E_p[L(Y,f(X))]=\int_{X\times Y} L(y,f(x))P(x,y)dxdy\]</span> 这是理论上模型<span class="math inline">\(f(X)\)</span>关于联合分布<span class="math inline">\(P(X,Y)\)</span>的平均意义下的损失，称为风险函数（risk function）或期望损失（expected loss）。<br>
学习的目标就是选择期望风险最小的模型。</p>
<p>模型<span class="math inline">\(f(X)\)</span>关于训练数据集的平均损失称为经验风险（empirical risk）或经验损失（empirical loss），记作<span class="math inline">\(R_{exp}\)</span>： <span class="math display">\[R_{exp}(f) = \frac{1}{N} \sum_{i=1}^N L(y_i,f(x_i))\]</span> 注意：<strong>期望风险<span class="math inline">\(R_{exp}(f)\)</span>是模型关于联合分布的期望损失，经验风险<span class="math inline">\(R_{exp}(f)\)</span>是模型关于训练样本集的平均损失。</strong> 当样本容量N趋于无穷时，经验风险趋于期望风险。</p>
<p><strong>（2）经验风险最小化和结构风险最小化</strong> （i）经验风险最小化（empirical risk minimization，ERM）<br>
经验风险最小化的策略认为经验风险最小的模型就是最优的模型： <span class="math display">\[\min_{f \in F} \frac{1}{N} \sum_{i=1}^N L(y_i,f(x_i))\]</span> 其中<span class="math inline">\(F\)</span>是假设空间。<br>
当样本容量足够大时，经验风险最小化能保证有比较好的学习效果。<br>
当模型是条件概率分布，损失函数是对数损失函数时，经验风险最小化等价于极大似然估计。<br>
当样本容量较小时，经验风险最小化会产生<strong>过拟合现象</strong>。</p>
<p>（ii）结构风险最小化（structural risk minimization，SRM）<br>
结构风险最小化是为了防止过拟合而提出的策略。<br>
结构风险最小化等价于<strong>正则化</strong>，就是在经验风险上加入表示模型复杂度的正则化项（regularizer），定义为：<br>
<span class="math display">\[R_{srm}(f)=\frac{1}{N} \sum_{i=1}^N L(y_i,f(x_i))+\lambda J(f)\]</span> 其中<span class="math inline">\(J(f)\)</span>为模型的复杂度，<span class="math inline">\(\lambda \geq 0\)</span>是系数，用以权衡经验风险和模型复杂度。<br>
结构风险小的模型往往对训练数据和未知的测试数据都有较好的预测。<br>
当模型是条件概率分布，损失函数是对数损失函数，模型复杂度由模型的先验概率表示时，结构风险最小化等 价于最大后验概率估计（maximum posterior probability estimation，MAP）。<br>
结构风险最小化的策略认为结构风险最小的模型就是最优模型： <span class="math display">\[\min_{f \in F} \frac{1}{N} \sum_{i=1}^N L(y_i,f(x_i)) + \lambda J(f)\]</span></p>
<p>此时，监督学习问题就变成了经验风险或结构风险函数的最优化问题，经验或结构风险函数就是最优化的目标函数。 ### 3.3. 算法 算法是指学习模型的具体计算方法。统计学习问题归结为最优化问题，统计学习的算法成为求解最优化问题的算法。如何保证找到全局最优解，并使求解的过程非常高效，就成为了一个重要的问题。</p>
<h2 id="模型评估与模型选择">4. 模型评估与模型选择</h2>
<h3 id="训练误差与测试误差">4.1. 训练误差与测试误差</h3>
<p>统计学习的目的是使学习到的模型不仅对已知数据而且对未知数据都能有很好的预测能力，不同的学习方法给出不同的模型，损失函数给定时，基于损失函数的模型的训练误差（training error）和模型的测试误差（test error）就成为学习方法评估的标准。<br>
假设学习到的模型为<span class="math inline">\(Y=\hat{f}(X)\)</span>，训练误差是模型<span class="math inline">\(Y=\hat{f}(X)\)</span>关于训练数据集的平均损失： <span class="math display">\[R_{emp}(\hat{f}) = \frac{1}{N} \sum_{i=1}^{N} L(y_i,\hat{f}(x_i))\]</span> 其中<span class="math inline">\(N\)</span>是训练样本容量。<br>
测试误差是模型<span class="math inline">\(Y=\hat{f}(X)\)</span>关于测试数据集的平均损失： <span class="math display">\[e_{test}=\frac{1}{N&#39;} \sum_{i=1}^{N&#39;} L(y_i, \hat{f}(x_i))\]</span> 其中<span class="math inline">\(N&#39;\)</span>是测试样本容量。<br>
训练误差的大小对于判定给定的问题是不是一个容易学习的问题是有意义的，测试误差反映了学习方法对未知的测试数据集的预测能力，即泛化能力（generalization ability）。</p>
<h3 id="过拟合和模型选择">4.2. 过拟合和模型选择</h3>
<p>当假设空间含有不同的复杂度（如不同的参数个数）的模型时，就要面临模型选择（model selection）的问题。一味的追求提高对训练数据的预测能力，所选的模型的复杂度往往会比真模型更高，这种现象称为过拟合（overfitting）。<br>
过拟合：学习时选择的模型包含的参数过多，导致模型对一直数据预测得很好，但对未知数据预测的很差的现象。</p>
<div class="figure">
<img src="http://p35icynkw.bkt.clouddn.com/屏幕快照%202018-01-27%20上午10.02.52.png">

</div>
<p>训练误差和测试误差与模型复杂度之间的关系。 <img src="http://p35icynkw.bkt.clouddn.com/屏幕快照%202018-01-27%20上午10.04.51.png"></p>
<p>学习时需要防止过拟合，进行最优的模型选择，即选择复杂度适当的模型，以达到使测试误差最小的学习目的，两种常用的模型选择方法：正则化和交叉验证。</p>
<h2 id="正则化与交叉验证">5. 正则化与交叉验证</h2>
<h3 id="正则化">5.1. 正则化</h3>
<p>正则化是结构风险最小化策略的实现，在经验风险上加一个正则项（regularizer）或罚项（penalty term），正则化项一般是模型复杂度的单调递增函数，模型越复杂，正则化值越大。<br>
一般形式：<br>
<span class="math display">\[\min_{f \in F} \frac{1}{N} \sum_{i=1}^{N} L(y_i,f(x_i)) + \lambda j(f)\]</span> 第一项为经验风险，第二项为正则项。<span class="math inline">\(\lambda \geq 0\)</span>为调整两者之间关系的系数。<br>
正则化的作用是选择经验风险与模型复杂度同时较小的模型。<br>
正则化符合奥卡姆剃刀原则（Occam's razor）原理：在所有可能选择的模型中，能够很好解释已知数据并十分简单的才是最好的模型。<br>
从贝叶斯估计的角度考虑：正则化项对应于模型的先验概率，可以假设复杂的模型有较小的先验概率，简单的模型有较大的先验概率。</p>
<h3 id="交叉验证">5.2. 交叉验证</h3>
<p>交叉验证是一种常用的模型选择方法。<br>
如果给定的样本数据充足，可以随机将数据集切分为三部分：训练集（training set）、验证集（validation set）和测试集（test set）。训练集用于训练模型，验证集用于模型的选择，测试集用于最终对学习方法的评估。学习不同复杂度的模型时，选择对验证集有较小预测误差的模型。<br>
当数据样本不充足时，可以采用交叉验证的方法。其基本思想是重复地使用数据，把给定的数据进行切分，将切分的数据集合组合为训练集和测试集，在此基础上反复地进行训练、测试以及模型选择。 交叉验证形式：</p>
<ul>
<li>简单交叉验证：随机地将给定数据集分为两部分，一部分作为训练集，另一部分作为测试集；</li>
<li>S折交叉验证：随机地将给定数据切分为S个互不相交的大小相同的子集，利用S-1个子集的数据训练模型，利用余下的子集测试模型，对可能的S种选择重复进行，最后选出S次评测中平均测试误差最小的模型；</li>
<li>留一交叉验证：S折交叉验证的特殊情形S=N。</li>
</ul>
<h2 id="泛化能力">6. 泛化能力</h2>
<h3 id="泛化误差">6.1. 泛化误差</h3>
<p>学习方法的泛化能力（generalization ability）是指该方法学习到的模型对未知数据的预测能力。<br>
如果学习到的模型是<span class="math inline">\(\hat{f}\)</span>，那么用这个模型对未知数据预测的误差即为泛化误差（generalization error）： <span class="math display">\[R_{exp}(\hat{f})=E_p[L(Y, \hat{f}(X))]=\int_{\chi \times \gamma} L(y,\hat{f}(x))P(x,y)dxdy \]</span> 泛化误差反映了学习方法的泛化能力，就是学习到的模型的期望风险。</p>
<h3 id="泛化误差上界generalization-error-bound">6.2. 泛化误差上界（generalization error bound）</h3>
<p>一般通过比较两种学习方法的泛化误差上界的大小来比较它们的优劣。<br>
性质：</p>
<ul>
<li>它是样本容量的函数，当样本容量增加时，泛化上界趋于0；</li>
<li>他是假设空间容量（capacity）的函数，假设空间容量越大，模型就越难学，泛化上界就越大。</li>
</ul>
<p><strong>泛化误差上界</strong>：对于二分类问题，当假设空间时有限个函数的集合<span class="math inline">\(F=\{f_1,f_2,\dots,f_d\}\)</span>时，对任意一个函数<span class="math inline">\(f \in F\)</span>，至少以概率$1-$，以下列不等式成立： <span class="math display">\[R(f) \leq \hat{R}(f) + \varepsilon (d,N,\delta )\]</span> 其中 <span class="math display">\[\begin{align}
    R(f) &amp;= E[L(Y,f(X))] \nonumber \\
    \hat{R}(f) &amp;= \frac{1}{N} \sum_{i=1}^N L(y_i,f(x_i)) \nonumber \\
    \varepsilon (d,N, \delta) &amp;= \sqrt{\frac{1}{2N} (\log{d}+  \log{\frac{1}{\delta}})} \nonumber
    \end{align}\]</span></p>
<p>不等式左端的<span class="math inline">\(R(f)\)</span>是泛化误差，右端即为泛化误差上界。在泛化误差上界中，第一项为训练误差，训练误差越小，泛化误差也越小；第二项<span class="math inline">\(\varepsilon (d,N,\delta )\)</span>是<span class="math inline">\(N\)</span>的单调递减函数，当<span class="math inline">\(N\)</span>趋于无穷时趋于0；同时它也是<span class="math inline">\(\sqrt{\log{d}}\)</span>阶的函数，假设空间<span class="math inline">\(F\)</span>包含的函数越多，其值越大。</p>
<p><strong>证明</strong>： Hoeffding不等式：设<span class="math inline">\(S_n = \sum_{i=1}^n X_i\)</span>是独立随机变量<span class="math inline">\(X_1,X_2, \cdots, X_n\)</span>之和，<span class="math inline">\(X_i \in [a_i,b_i]\)</span>，则对任意<span class="math inline">\(t &gt; 0\)</span>，有以下不等式成立： <span class="math display">\[\begin{align}
    P(S_n-ES_n \geq t) \leq exp(\frac{-2t^2}{\sum_{i=1}^n (b_i - a_i)^2}) \nonumber \\
    P(ES_n-S_n \geq t) \leq exp(\frac{-2t^2}{\sum_{i=1}^n (b_i - a_i)^2}) \nonumber
\end{align}\]</span></p>
<p>对任意函数<span class="math inline">\(f \in F\)</span>，<span class="math inline">\(\hat{R}(f)\)</span>是<span class="math inline">\(N\)</span>个独立的随机变量<span class="math inline">\(L(Y,f(X))\)</span>的样本均值，<span class="math inline">\(R(f)\)</span>是随机变量<span class="math inline">\(L(Y,f(X))\)</span>的期望值，如果损失函数取值于区间<span class="math inline">\([0,1]\)</span>，即对所有i，<span class="math inline">\([a_i,b_i]=[0,1]\)</span>，那么由Hoeffding不等式中的第二条可以得到，对<span class="math inline">\(\varepsilon = \frac{t}{N} &gt; 0\)</span>，有以下不等式成立： <span class="math display">\[P(R(f) - \hat{R}(f) \geq \varepsilon ) \leq exp(-2N \varepsilon ^2)\]</span>   由于<span class="math inline">\(F=\{f_1,f_2, \cdots ,f_d\}\)</span>是一个有限集合，故 <span class="math display">\[\begin{align}
P(R(f) - \hat{R}(f)&lt; \varepsilon) &amp;\geq P(\bigcup_{f \in F}\{R(f) - \hat{R}(f) \geq \varepsilon \}) \nonumber \\
&amp;\leq \sum_{f \in F}P(R(f) - \hat{R}(f) \geq \varepsilon ) \nonumber \\
&amp;\leq d exp(-2N \varepsilon ^2) \nonumber
\end{align}\]</span></p>
<p>或者等价的，对任意<span class="math inline">\(f \in F\)</span>，有 <span class="math display">\[P(R(f) - \hat{R}(f) &lt; \varepsilon ) \geq 1 - d exp(-2N \varepsilon ^2)\]</span> 令  <span class="math inline">\(\delta = d exp(-2N \varepsilon ^2)\)</span>，那么有： <span class="math display">\[P(R(f) &lt; \hat{R}(f) + \varepsilon ) \geq 1 - \delta\]</span> 即至少以概率<span class="math inline">\(1 - \delta\)</span>有<span class="math inline">\(R(f) &lt; \hat{R}(f) + \varepsilon\)</span>。<br>
以上讨论的只是假设空间包含有限个函数情况下的泛化误差上界，对于一般的假设空间要找到误差上界并没有这么简单。 ## 7. 生成模型与判别模型 监督学习方法可分为生成方法（generative approach）和判别方法（discriminative approach），所学到的模型分别称为生成模型（generative model）和判别模型（discriminative model）。<br>
### 7.1. 生成方法 生成方法由数据学习联合概率分布<span class="math inline">\(P(X,Y)\)</span>，然后求出条件概率分布<span class="math inline">\(P(Y|X)\)</span>作为预测模型，即生成模型： <span class="math display">\[P(Y|X) = \frac{P(X,Y)}{P(X)}\]</span> 这种方法成为生成方法，因为模型表示了给定输入<span class="math inline">\(X\)</span>产生输出<span class="math inline">\(Y\)</span>的生成关系。<br>
典型的生成模型：朴素贝叶斯法、隐马尔科夫模型。<br>
特点：</p>
<ul>
<li>生成方法可以还原出联合概率分布<span class="math inline">\(P(X,Y)\)</span>，而判别方法不能；</li>
<li>生成方法的学习收敛速度更快，即当样本容量增加时，学到的模型可以更快的收敛到真实模型；</li>
<li>当存在隐变量时，仍可以用生成方法学习，此时判别方法不能用。</li>
</ul>
<h3 id="判别方法">7.2. 判别方法</h3>
<p>判别方法由数据直接学习决策函数<span class="math inline">\(f(X)\)</span>或者条件概率分布<span class="math inline">\(P(Y|X)\)</span>作为预测的模型，即判别模型。<br>
典型的判别模型：k近邻法、感知机、决策树、logistic回归模型、最大熵模型、支持向量机、提升方法和条件随机场。<br>
特点：</p>
<ul>
<li>判别方法直接学习条件概率<span class="math inline">\(P(Y|X)\)</span>或决策函数<span class="math inline">\(f(X)\)</span>，直接预测，往往准确度更高；</li>
<li>犹豫直接学习<span class="math inline">\(P(Y|X)\)</span>或<span class="math inline">\(f(X)\)</span>，可以对数据进行各种程度上的抽象、定义特征并使用特征，简化学习问题。</li>
</ul>
<h2 id="分类问题">8. 分类问题</h2>
<p>输入变量X可以是离散的，也可以是连续的，而输出变量是有限个离散的值，该预测问题为分类问题。<br>
分类问题包括学习和分类两个过程：学习过程中，根据已知的训练数据集利用有效的学习方法学习一个分类器；分类过程中，利用学习的分类器对新的输入实例进行分类。 <img src="http://p35icynkw.bkt.clouddn.com/屏幕快照%202018-01-28%20下午3.21.38.png"></p>
<p>评价分类器性能的指标一般是分类准确率（accuracy）：对于给定的测试数据集，分类器正确分类的样本数与总样本数之比。<br>
常用的指标是精确率（precision）与召回率（recall），通常关注一下4中情况：</p>
<ul>
<li>TP——将正类预测为正类数；</li>
<li>FN——将正类预测为负类数；</li>
<li>FP——将负类预测为正类数；</li>
<li>TN——将负类预测为负类数。</li>
</ul>
<p>精确率定义为： <span class="math display">\[P = \frac{TP}{TP+FP} \]</span> 召回率定义为： <span class="math display">\[R = \frac{TP}{TP+FN} \]</span> <span class="math inline">\(F_1\)</span>值为精确率和召回率的调和均值，即 <span class="math display">\[\begin{equation}
    \frac{2}{F_1} = \frac{1}{P} + \frac{1}{R} \nonumber \\
    F_1 = \frac{2TP}{2TP+FP+FN}
\end{equation}\]</span></p>
<p>用于分类的统计学习方法：k近邻法、感知机、朴素贝叶斯法、决策树、决策列表、logistic回归模型、支持向量机、提升方法、贝叶斯网络、神经网络、Winnow等。</p>
<h2 id="标注问题">9. 标注问题</h2>
<p>标注问题是分类问题的推广，输入是一个观测序列，输出是一个标记序列或状态序列。<br>
标注问题的目标在于学习一个模型，使它能够对观测序列给出标记序列作为预测。具体地，对于一个观测序列<span class="math inline">\(x_{N+1} = (x_{N+1}^{(1)}, x_{N+1}^{(2)}, \cdots, x_{N+1}^{(n)})^T\)</span>找到是条件概率<span class="math inline">\(P((y_{N+1}^{(1)}, y_{N+1}^{(2)}, \cdots, y_{N+1}^{(n)})^T|(x_{N+1}^{(1)}, x_{N+1}^{(2)}, \cdots, x_{N+1}^{(n)})^T)\)</span>最大的标记序列<span class="math inline">\(y_{N+1}=(y_{N+1}^{(1)}, y_{N+1}^{(2)}, \cdots, y_{N+1}^{(n)})^T\)</span>。 <img src="http://p35icynkw.bkt.clouddn.com/屏幕快照%202018-01-28%20下午3.37.38.png"></p>
<p>标注常用的统计学习方法：隐马尔科夫模型、条件随机场。</p>
<h2 id="回归问题">10. 回归问题</h2>
<p>回归用于预测输入变量（自变量）和输出变量（因变量）之间的关系，回归模型正是表示从输入变量到输出变量之间映射的函数，等价于函数拟合：选择一条函数曲线使其很好地拟合已知数据且很好地预测未知数据。 <img src="http://p35icynkw.bkt.clouddn.com/屏幕快照%202018-01-28%20下午3.42.58.png"></p>
<p>回归问题按照输入变量的个数，分为一元回归和多元回归；按照输入变量和输出变量之间关系的类型即模型的类型，分为线性回归和非线性回归。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/统计学习/" rel="tag"># 统计学习</a>
          
            <a href="/tags/概论/" rel="tag"># 概论</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/01/13/想法/起点/" rel="next" title="又一个起点">
                <i class="fa fa-chevron-left"></i> 又一个起点
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/01/14/机器学习/集成学习/" rel="prev" title="集成学习">
                集成学习 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">silen Zhou</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">38</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#统计学习方法概论"><span class="nav-number">1.</span> <span class="nav-text">统计学习方法概论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#统计学习"><span class="nav-number">1.1.</span> <span class="nav-text">1. 统计学习</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对象及方法"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1. 对象及方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#步骤"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.2. 步骤</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#监督学习"><span class="nav-number">1.2.</span> <span class="nav-text">2. 监督学习</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本概念"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1. 基本概念</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#统计学习三要素"><span class="nav-number">1.3.</span> <span class="nav-text">3. 统计学习三要素</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#模型"><span class="nav-number">1.3.1.</span> <span class="nav-text">3.1. 模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#策略"><span class="nav-number">1.3.2.</span> <span class="nav-text">3.2. 策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模型评估与模型选择"><span class="nav-number">1.4.</span> <span class="nav-text">4. 模型评估与模型选择</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#训练误差与测试误差"><span class="nav-number">1.4.1.</span> <span class="nav-text">4.1. 训练误差与测试误差</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#过拟合和模型选择"><span class="nav-number">1.4.2.</span> <span class="nav-text">4.2. 过拟合和模型选择</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#正则化与交叉验证"><span class="nav-number">1.5.</span> <span class="nav-text">5. 正则化与交叉验证</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#正则化"><span class="nav-number">1.5.1.</span> <span class="nav-text">5.1. 正则化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#交叉验证"><span class="nav-number">1.5.2.</span> <span class="nav-text">5.2. 交叉验证</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#泛化能力"><span class="nav-number">1.6.</span> <span class="nav-text">6. 泛化能力</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#泛化误差"><span class="nav-number">1.6.1.</span> <span class="nav-text">6.1. 泛化误差</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#泛化误差上界generalization-error-bound"><span class="nav-number">1.6.2.</span> <span class="nav-text">6.2. 泛化误差上界（generalization error bound）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#判别方法"><span class="nav-number">1.6.3.</span> <span class="nav-text">7.2. 判别方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分类问题"><span class="nav-number">1.7.</span> <span class="nav-text">8. 分类问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标注问题"><span class="nav-number">1.8.</span> <span class="nav-text">9. 标注问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#回归问题"><span class="nav-number">1.9.</span> <span class="nav-text">10. 回归问题</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">silen Zhou</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.0.2</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.0.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.0.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.2"></script>



  



	





  





  










  





  

  

  

  
  

  
  

  
    
      <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->

    
  


  
  

  

  

  

  

</body>
</html>
