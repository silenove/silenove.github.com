<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-EN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.2" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.2">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.2" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.0.2',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="机器学习,概率图模型," />


<meta name="description" content="条件随机场 条件随机场（conditional random field，CRF）是给定一组输入随机变量条件下另一组输出随机变量的条件概率分布模型，其特点是假设输出随机变量构成马尔可夫随机场。 1. 定义 条件随机场是给定随机变量\(X\)条件下，随机变量\(Y\)的马尔可夫随机场。 条件随机场：设\(X\)和\(Y\)是随机变量，\(P(Y|X)\)是在给定\(X\)的条件下\(Y\)的条件概率">
<meta name="keywords" content="机器学习,概率图模型">
<meta property="og:type" content="article">
<meta property="og:title" content="条件随机场">
<meta property="og:url" content="http://yoursite.com/2018/04/16/机器学习/条件随机场/index.html">
<meta property="og:site_name" content="silenove blogs">
<meta property="og:description" content="条件随机场 条件随机场（conditional random field，CRF）是给定一组输入随机变量条件下另一组输出随机变量的条件概率分布模型，其特点是假设输出随机变量构成马尔可夫随机场。 1. 定义 条件随机场是给定随机变量\(X\)条件下，随机变量\(Y\)的马尔可夫随机场。 条件随机场：设\(X\)和\(Y\)是随机变量，\(P(Y|X)\)是在给定\(X\)的条件下\(Y\)的条件概率">
<meta property="og:locale" content="zh-EN">
<meta property="og:image" content="http://p35icynkw.bkt.clouddn.com/屏幕快照%202018-04-11%20下午9.31.03.png">
<meta property="og:image" content="http://p35icynkw.bkt.clouddn.com/屏幕快照%202018-04-12%20上午10.45.08.png">
<meta property="og:image" content="http://p35icynkw.bkt.clouddn.com/屏幕快照%202018-04-15%20下午7.27.34.png">
<meta property="og:image" content="http://p35icynkw.bkt.clouddn.com/屏幕快照%202018-04-16%20下午4.31.19.png">
<meta property="og:image" content="http://p35icynkw.bkt.clouddn.com/屏幕快照%202018-04-16%20下午5.22.40.png">
<meta property="og:updated_time" content="2018-04-16T09:26:22.391Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="条件随机场">
<meta name="twitter:description" content="条件随机场 条件随机场（conditional random field，CRF）是给定一组输入随机变量条件下另一组输出随机变量的条件概率分布模型，其特点是假设输出随机变量构成马尔可夫随机场。 1. 定义 条件随机场是给定随机变量\(X\)条件下，随机变量\(Y\)的马尔可夫随机场。 条件随机场：设\(X\)和\(Y\)是随机变量，\(P(Y|X)\)是在给定\(X\)的条件下\(Y\)的条件概率">
<meta name="twitter:image" content="http://p35icynkw.bkt.clouddn.com/屏幕快照%202018-04-11%20下午9.31.03.png">






  <link rel="canonical" href="http://yoursite.com/2018/04/16/机器学习/条件随机场/"/>


  <title>条件随机场 | silenove blogs</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-EN">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">silenove blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">沿路旅程如歌褪变</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Beranda</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Arsip</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/16/机器学习/条件随机场/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="silen Zhou">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="silenove blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">条件随机场</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Diposting di</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-16T17:25:42+08:00">2018-04-16</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="条件随机场">条件随机场</h1>
<p><strong>条件随机场（conditional random field，CRF）</strong>是给定一组输入随机变量条件下另一组输出随机变量的条件概率分布模型，其特点是假设输出随机变量构成马尔可夫随机场。</p>
<h2 id="定义">1. 定义</h2>
<p>条件随机场是给定随机变量<span class="math inline">\(X\)</span>条件下，随机变量<span class="math inline">\(Y\)</span>的马尔可夫随机场。</p>
<p><strong>条件随机场</strong>：设<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>是随机变量，<span class="math inline">\(P(Y|X)\)</span>是在给定<span class="math inline">\(X\)</span>的条件下<span class="math inline">\(Y\)</span>的条件概率分布。若随机变量<span class="math inline">\(Y\)</span>构成一个由无向图<span class="math inline">\(G = (V,E)\)</span>表示的马尔可夫随机场，即 <span class="math display">\[P(Y_v|X,Y_w, w \neq v) = P(Y_v|X,Y_w,w \sim v)\]</span> 对任意结点<span class="math inline">\(v\)</span>成立，则称条件概率分布<span class="math inline">\(P(Y|X)\)</span>为条件随机场。式中<span class="math inline">\(w \sim v\)</span>表示在图<span class="math inline">\(G = (V,E)\)</span>中与结点<span class="math inline">\(v\)</span>有边连接的所有结点<span class="math inline">\(w\)</span>，<span class="math inline">\(w \neq v\)</span>表示结点<span class="math inline">\(v\)</span>以外的所有结点，<span class="math inline">\(Y_v,Y_u\)</span>与<span class="math inline">\(Y_w\)</span>为结点<span class="math inline">\(v,u\)</span>和<span class="math inline">\(w\)</span>对应的随机变量。</p>
<p>定义中并没有要求<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>具有相同的结构。现实中，一般假设<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>有相同的图结构。此处主要考虑无向图为图11.4和图11.5所示的线性链的情况，即 <span class="math display">\[G = (V = \{1,2,\cdots,n\}, \quad E = \{(i,i+1)\}), \quad i=1,2,\cdots,n-1\]</span> 在此情况下，<span class="math inline">\(X=(X_1,X_2,\cdots,X_n), \quad Y=(Y_1,Y_2,\cdots,Y_n)\)</span>，最大团是相邻两个结点的集合。</p>
<div class="figure">
<img src="http://p35icynkw.bkt.clouddn.com/屏幕快照%202018-04-11%20下午9.31.03.png">

</div>
<p><strong>线性链条件随机场</strong>：设<span class="math inline">\(X=(X_1,X_2,\cdots,X_n), \quad Y=(Y_1,Y_2,\cdots,Y_n)\)</span>均为线性链表示的随机变量序列，若在给定随机变量序列<span class="math inline">\(X\)</span>的条件下，随机变量序列<span class="math inline">\(Y\)</span>的条件概率分布<span class="math inline">\(P(Y|X)\)</span>构成条件随机场，即满足马尔可夫性 <span class="math display">\[\begin{equation}
    P(Y_i|X,Y_1,\cdots,Y_{i-1},Y_{i+1},\cdots,Y_n) = P(Y_i|X,Y_{i-1},Y_{i+1}) \nonumber \\
    i = 1,2,\cdots,n(在i=1和n时只考虑单边) \nonumber
\end{equation}\]</span></p>
<p>则称<span class="math inline">\(P(Y|X)\)</span>为线性链条件随机场。在标注问题中，<span class="math inline">\(X\)</span>表示输入观测序列，<span class="math inline">\(Y\)</span>表示对应的输出标记序列或状态序列。</p>
<h2 id="参数化形式">2. 参数化形式</h2>
<p><strong>线性链条件随机场的参数化形式</strong>：设<span class="math inline">\(P(Y|X)\)</span>为线性链条件随机场，则在随机变量<span class="math inline">\(X\)</span>取值为<span class="math inline">\(\pmb{x}\)</span>的条件下，随机变量<span class="math inline">\(Y\)</span>取值为<span class="math inline">\(y\)</span>的条件概率具有如下形式： <span class="math display">\[P(y|\pmb{x}) = \frac{1}{Z(\pmb{x})} \exp \left( \sum_{i,k} \lambda_k t_k (y_{i-1},y_i, \pmb{x}, i) + \sum_{i,l} \mu_l s_l (y_i, \pmb{x}, i) \right)\]</span> 其中 <span class="math display">\[Z(\pmb{x}) = \sum_y \exp \left( \sum_{i,k} \lambda_k t_k (y_{i-1},y_i, \pmb{x}, i) + \sum_{i,l} \mu_l s_l (y_i, \pmb{x}, i) \right)\]</span> 式中，<span class="math inline">\(t_k\)</span>和<span class="math inline">\(s_l\)</span>是特征函数，<span class="math inline">\(\lambda_k\)</span>和<span class="math inline">\(\mu_l\)</span>是对应的权值。<span class="math inline">\(Z(x)\)</span>是规范化因子，求和是在所有可能的输出序列上进行的。<br>
上述公式是线性条件随机场模型的基本形式，表示给定输入序列<span class="math inline">\(\pmb{x}\)</span>，对输出序列<span class="math inline">\(\pmb{y}\)</span>预测的条件概率。其中<span class="math inline">\(t_k\)</span>是定义在边上的特征函数，称为转移特征，依赖于当前和前一个位置；<span class="math inline">\(s_l\)</span>是定义在结点上的特征函数，称为状态特征，依赖于当前位置。<span class="math inline">\(t_k\)</span>和<span class="math inline">\(s_l\)</span>都依赖于位置，是局部特征函数。通常，特征函数<span class="math inline">\(t_k\)</span>和<span class="math inline">\(s_l\)</span>取值为1或0；当满足特征条件时取值为1，否则为0。条件随机场完全由特征函数<span class="math inline">\(t_k\)</span>，<span class="math inline">\(s_l\)</span>和对应的权值<span class="math inline">\(\lambda_k,\mu_l\)</span>确定。</p>
<p>线性链条件随机场也是对数线性模型。</p>
<h2 id="简化形式">3. 简化形式</h2>
<p>条件随机场还可以由简化形式表示。<strong>条件随机场中同一特征在各个位置都有定义，可以对同一特征在各个位置求和，将局部特征函数转化为一个全局特征函数，这样就可以将条件随机场写成权值向量和特征向量的内积形式</strong>，即条件随机场的简化形式。</p>
<p>首先将转移特征和状态特征及其权值用统一的符号表示。，设有<span class="math inline">\(K_1\)</span>个转移特征，<span class="math inline">\(K_2\)</span>个状态特征，<span class="math inline">\(K = K_1 + K_2\)</span>，记 <span class="math display">\[f_k(y_{i-1},y_i,\pmb{x},i) =
    \begin{cases}
        t_k(y_{i-1},y_i,\pmb{x},i), \quad k=1,2,\cdots,K_1 \\
        s_l(y_i,\pmb{x},i), \quad k=K_1 + l;l=1,2,\cdots,K_2
    \end{cases}\]</span></p>
<p>然后，对转移与状态特征在各个位置<span class="math inline">\(i\)</span>求和，记作 <span class="math display">\[f_k (\pmb{y},\pmb{x}) = \sum_{i=1}^n f_k(y_{i-1},y_i,\pmb{x},i), \quad k=1,2,\cdots,K\]</span> 用<span class="math inline">\(w_k\)</span>表示特征<span class="math inline">\(f_k (\pmb{y},\pmb{x})\)</span>的权值，即 <span class="math display">\[w_k = 
    \begin{cases}
        \lambda_k, \quad k=1,2,\cdots,K_1 \\
        \mu_l, \quad k=K_1 + l;l=1,2,\cdots,K_2
    \end{cases}\]</span> 于是，条件随机场可表示为 <span class="math display">\[\begin{align}
    P(\pmb{y}|\pmb{x}) &amp;= \frac{1}{Z(\pmb{x})} \exp \sum_{k=1}^K w_k f_k(\pmb{y},\pmb{x}) \tag{11.15} \\
    Z(\pmb{x}) &amp;= \sum_{\pmb{y}} \exp \sum_{k=1}^K w_k f_k(\pmb{y},\pmb{x}) \tag{11.16} 
\end{align}\]</span></p>
<p>若以<span class="math inline">\(\pmb{w}\)</span>表示权值向量，即 <span class="math display">\[\pmb{w} = (w_1,w_2,\cdots,w_K)^T\]</span> 以<span class="math inline">\(F(\pmb{y},\pmb{x})\)</span>表示全局特征向量，即 <span class="math display">\[F(\pmb{y}, \pmb{x}) = (f_1(\pmb{y},\pmb{x}),f_2(\pmb{y},\pmb{x}),\cdots,f_K(\pmb{y},\pmb{x}))^T\]</span> 则条件随机场可以写成向量<span class="math inline">\(\pmb{w}\)</span>与<span class="math inline">\(F(\pmb{y},\pmb{x})\)</span>的内积的形式： <span class="math display">\[P_{\pmb{w}}(\pmb{y}|\pmb{x}) = \frac{\exp(\pmb{w} \cdot F(\pmb{y},\pmb{x}))}{Z_{\pmb{w}}(\pmb{x})}\]</span> 其中 <span class="math display">\[Z_{\pmb{w}}(\pmb{x}) = \sum_{\pmb{y}} \exp(\pmb{w} \cdot F(\pmb{y},\pmb{x}))\]</span></p>
<h2 id="矩阵形式">4. 矩阵形式</h2>
<p>条件随机场还可以由矩阵表示。假设<span class="math inline">\(P_{\pmb{w}}(\pmb{y}|\pmb{x})\)</span>是式（11.15）~（11.16）给出的线性链条件随机场，表示对给定观测序列<span class="math inline">\(\pmb{x}\)</span>，相应的标记序列<span class="math inline">\(\pmb{y}\)</span>的条件概率。引入特殊的起点和终点状态标记<span class="math inline">\(y_0 = start,\quad y_{n+1} = stop\)</span>，这时<span class="math inline">\(P_{\pmb{w}}(\pmb{y}|\pmb{x})\)</span>可以通过矩阵形式表示。</p>
<p>对观测序列<span class="math inline">\(\pmb{x}\)</span>的每一个位置<span class="math inline">\(i=1,2,\cdots,n+1\)</span>，定义一个<span class="math inline">\(m\)</span>阶矩阵（<span class="math inline">\(m\)</span>是标记<span class="math inline">\(y_i\)</span>取值的个数）： <span class="math display">\[\begin{equation}
    M_i(\pmb{x}) = [M_i(y_{i-1},y_i|\pmb{x})] \nonumber \\
    M_i(y_{i-1},y_i|\pmb{x}) = \exp(W_i(y_{i-1},y_i|\pmb{x})) \nonumber \\
    W_i(y_{i-1},y_i|\pmb{x}) = \sum_{k=1}^K w_k f_k (y_{i-1},y_i,\pmb{x},i) \nonumber
\end{equation}\]</span> 这样，给定观测序列<span class="math inline">\(\pmb{x}\)</span>，相应的标记序列<span class="math inline">\(\pmb{y}\)</span>的非规范化概率可以通过该序列<span class="math inline">\(n+1\)</span>个矩阵适当元素的乘积<span class="math inline">\(\prod_{i=1}^{n+1} M_i(y_{i-1},y_i|\pmb{x})\)</span>表示。于是，条件概率<span class="math inline">\(P_{\pmb{w}}(\pmb{y}|\pmb{x})\)</span>是 <span class="math display">\[P_{\pmb{w}}(\pmb{y}|\pmb{x}) = \frac{1}{Z_{\pmb{w}}(\pmb{x})} \prod_{i=1}^{n+1} M_i(y_{i-1},y_i|\pmb{x})\]</span> 其中，<span class="math inline">\(Z_{\pmb{w}}(\pmb{x})\)</span>为规范化因子，是<span class="math inline">\(n+1\)</span>个矩阵的乘积的（start，stop）元素： <span class="math display">\[Z_{\pmb{w}}(\pmb{x}) = (M_1(\pmb{x})M_2(\pmb{x})\cdots M_{n+1}(\pmb{x}))_{start,stop}\]</span> 注意，<span class="math inline">\(y_0 = start\)</span>与<span class="math inline">\(y_{n+1} = stop\)</span>表示开始状态与终止状态，规范化因子<span class="math inline">\(Z_{\pmb{w}}(\pmb{x})\)</span>是以start为起点stop为终点通过状态的所有路径<span class="math inline">\(y_1 y_2 \cdots y_n\)</span>的非规范化概率<span class="math inline">\(\prod_{i=1}^{n+1} M_i(y_{i-1},y_i|\pmb{x})\)</span>之和。</p>
<p>示例：<br>
<img src="http://p35icynkw.bkt.clouddn.com/屏幕快照%202018-04-12%20上午10.45.08.png"></p>
<h2 id="概率计算问题">5. 概率计算问题</h2>
<p>条件随机场的概率计算问题是给定条件随机场<span class="math inline">\(P(Y|X)\)</span>，输入序列<span class="math inline">\(\pmb{x}\)</span>和输出序列<span class="math inline">\(\pmb{y}\)</span>，计算条件概率<span class="math inline">\(P(Y_i = y_i|\pmb{x})\)</span>，<span class="math inline">\(P(Y_{i-1}=y_{i-1},Y_i = y_i|\pmb{x})\)</span>以及相应的数学期望的问题。与HMM相类似，引入前向-后向向量，递归地计算以上概率及期望值，这样的算法称为前向-后向算法。</p>
<h3 id="前向-后向算法">5.1. 前向-后向算法</h3>
<p>对每个指标<span class="math inline">\(i=0,1,\cdots,n+1\)</span>，定义前向向量<span class="math inline">\(\alpha_i(\pmb{x})\)</span>： <span class="math display">\[\alpha_0 (\pmb{y}|\pmb{x}) = 
    \begin{cases}
        1, \quad \pmb{y}=start \\
        0, \quad 否则
    \end{cases}\]</span></p>
<p>递推公式为 <span class="math display">\[\alpha_i^T (y_i|\pmb{x}) = \alpha_{i-1}^T(y_{i-1}|\pmb{x}) [M_i(y_{i-1},y_i|\pmb{x})], \quad i=1,2,\cdots,n+1\]</span> 又可表示为 <span class="math display">\[\alpha_i^T (\pmb{x}) = \alpha_{i-1}^T (\pmb{x}) M_i(\pmb{x})\]</span> <span class="math inline">\(\alpha_i(y_i|\pmb{x})\)</span>表示在位置<span class="math inline">\(i\)</span>的标记是<span class="math inline">\(y_i\)</span>并且到位置<span class="math inline">\(i\)</span>的前部分标记序列的非规范化概率，<span class="math inline">\(y_i\)</span>可取的值有<span class="math inline">\(m\)</span>个，所以<span class="math inline">\(\alpha_i(\pmb{x})\)</span>是<span class="math inline">\(m\)</span>维列向量。</p>
<p>同样，对每个指标<span class="math inline">\(i=0,1,\cdots,n+1\)</span>，定义后向向量<span class="math inline">\(\beta_i(\pmb{x})\)</span>： <span class="math display">\[\begin{equation}
    \beta_{n+1}(y_{n+1}|\pmb{x}) = 
        \begin{cases}
            1, \quad y_{n+1} = stop \\
            0, \quad 否则
        \end{cases} \nonumber \\
    \beta_i(y_i|\pmb{x}) = [M_i(y_i,y_{i+1}|\pmb{x})] \beta_{i+1} (y_{i+1}|\pmb{x}) \nonumber
\end{equation}\]</span></p>
<p>又可表示为 <span class="math display">\[\beta_i(\pmb{x}) = M_{i+1} (\pmb{x}) \beta_{i+1} (\pmb{x})\]</span> <span class="math inline">\(\beta_i(y_i|\pmb{x})\)</span>表示在位置<span class="math inline">\(i\)</span>的标记为<span class="math inline">\(y_i\)</span>并且从<span class="math inline">\(i+1\)</span>到<span class="math inline">\(n\)</span>的后部分标记序列的非规范化概率。</p>
<p>由前向-后向向量定义可以得到： <span class="math display">\[Z(\pmb{x}) = \alpha_n^T (\pmb{x}) \cdot \pmb{1} = \pmb{1}^T \cdot \beta_1(\pmb{x})\]</span> <span class="math inline">\(\pmb{1}\)</span>是元素均为1的<span class="math inline">\(m\)</span>维列向量。</p>
<h3 id="概率计算">5.2. 概率计算</h3>
<p>按照前向-后向向量的定义，可以计算标记序列在位置<span class="math inline">\(i\)</span>是标记<span class="math inline">\(y_i\)</span>的条件概率和在位置<span class="math inline">\(i-1\)</span>与<span class="math inline">\(i\)</span>是标记<span class="math inline">\(y_{i-1}\)</span>和<span class="math inline">\(y_i\)</span>的条件概率： <span class="math display">\[\begin{align}
    P(Y_i = y_i|\pmb{x}) &amp;= \frac{\alpha_i^T (y_i|\pmb{x}) \beta_i(y_i|\pmb{x})}{Z(\pmb{x})} \nonumber \\
    P(Y_{i-1} = y_{i-1},Y_i = y_i |\pmb{x}) &amp;= \frac{\alpha_{i-1}^T (y_{i-1}|\pmb{x}) M_i(y_{i-1},y_i|\pmb{x}) \beta_i(y_i|\pmb{x})}{Z(\pmb{x})} \nonumber
\end{align}\]</span> 其中 <span class="math display">\[Z(\pmb{x}) = \alpha_n^T (\pmb{x}) \cdot \pmb{1}\]</span></p>
<h3 id="期望值计算">5.3. 期望值计算</h3>
<p>利用前向-后向向量，可以计算特征函数关于联合分布<span class="math inline">\(P(X,Y)\)</span>和条件分布<span class="math inline">\(P(Y|X)\)</span>的数学期望。<br>
特征函数<span class="math inline">\(f_k\)</span>关于条件分布<span class="math inline">\(P(Y|X)\)</span>的数学期望是 <span class="math display">\[\begin{align}
    E_{P(Y|X)} [f_k] &amp;= \sum_{\pmb{y}} P(\pmb{y}|\pmb{x}) f_k(\pmb{y},\pmb{x}) \nonumber \\
    &amp;= \sum_{i=1}^{n+1} \sum_{y_{i-1}y_i} f_k(y_{i-1},y_i,\pmb{x},i) \frac{\alpha_{i-1}^T (y_{i-1}|\pmb{x})M_i(y_{i-1},y_i|\pmb{x}) \beta_i(y_i|\pmb{x})}{Z(\pmb{x})} \nonumber \\
    &amp; \qquad k=1,2,\cdots,K \nonumber
\end{align}\]</span> 其中， <span class="math display">\[Z(\pmb{x}) = \alpha_n^T (\pmb{x}) \cdot \pmb{1}\]</span></p>
<p>假设经验分布为<span class="math inline">\(\tilde{P}(X)\)</span>，特征函数<span class="math inline">\(f_k\)</span>关于联合分布<span class="math inline">\(P(X,Y)\)</span>的数学期望是 <span class="math display">\[\begin{align}
    E_{P(X,Y)} [f_k] &amp;= \sum_{\pmb{x},\pmb{y}} P(\pmb{x},\pmb{y}) \sum_{i=1}^{n+1} f_k(y_{i-1},y_i,\pmb{x},i) \nonumber \\
    &amp;= \sum_{\pmb{x}} \tilde{P}(\pmb{x}) \sum_{\pmb{y}} P(\pmb{y}|\pmb{x}) \sum_{i=1}^{n+1} f_k(y_{i-1},y_i,\pmb{x},i) \nonumber \\
    &amp;= \sum_{\pmb{x}} \tilde{P}(\pmb{x}) \sum_{i=1}^{n+1} \sum_{y_{i-1}y_i} f_k(y_{i-1},y_i,\pmb{x},i) \frac{\alpha_{i-1}^T(y_{i-1}|\pmb{x})M_i(y_{i-1},y_i|\pmb{x}) \beta_i(y_i|\pmb{x})}{Z(\pmb{x})} \nonumber \\
    &amp; \qquad k=1,2,\cdots,K \nonumber
\end{align}\]</span> 其中 <span class="math display">\[Z(\pmb{x}) = \alpha_n^T (\pmb{x}) \cdot \pmb{1}\]</span> 上述两个公式是特征函数数学期望的一般计算公式。对于转移特征<span class="math inline">\(t_k(y_{i-1},y_i,\pmb{x},i), \quad k=1,2,\cdots,K_1\)</span>，可以将式中的<span class="math inline">\(f_k\)</span>换成<span class="math inline">\(t_k\)</span>；对于状态特征，可以将式中的<span class="math inline">\(f_k\)</span>换成<span class="math inline">\(s_l\)</span>，表示为<span class="math inline">\(s_l(y_i,\pmb{x},i), \quad k=K_1 + l, \quad l=1,2,\cdots,K_2\)</span>。<br>
对于给定的观测序列<span class="math inline">\(\pmb{x}\)</span>与标记序列<span class="math inline">\(\pmb{y}\)</span>，可以通过以此前向扫描计算<span class="math inline">\(\alpha_i\)</span>及<span class="math inline">\(Z(\pmb{x})\)</span>，通过一次后向扫描计算<span class="math inline">\(\beta_i\)</span>，从而计算所有的概率和特征的期望。</p>
<h2 id="学习算法">6. 学习算法</h2>
<p>条件随机场模型实际上是定义在时序数据上的对数线性模型，其学习方法包括极大似然估计和正则化的极大似然估计。具体地优化实现算法有改进的迭代尺度法IIS、梯度下降法以及拟牛顿法。</p>
<h3 id="改进的迭代尺度法">6.1. 改进的迭代尺度法</h3>
<p>已知训练数据集，由此可知经验概率分布<span class="math inline">\(\tilde{P}(X,Y)\)</span>。可以通过极大化训练数据的对数似然函数来求模型参数。</p>
<p>训练数据的对数似然函数为 <span class="math display">\[L(\pmb{w}) = L_{\tilde{P}}(P_{\pmb{w}}) = \log \prod_{\pmb{x},\pmb{y}} P_{\pmb{w}} (\pmb{y}|\pmb{x})^{\tilde{P}(\pmb{x},\pmb{y})} = \sum_{\pmb{x},\pmb{y}} \tilde{P}(\pmb{x},\pmb{y}) \log P_{\pmb{w}} (\pmb{y}|\pmb{x})\]</span> 当<span class="math inline">\(P_{\pmb{w}}\)</span>是一个由式（11.15）和（11.16）给出的条件随机场模型时，对数似然函数为 <span class="math display">\[\begin{align}
    L(\pmb{w}) &amp;= \sum_{\pmb{x},\pmb{y}} \tilde{P}(\pmb{x},\pmb{y})\log P_{\pmb{w}} (\pmb{y}|\pmb{x}) \nonumber \\
    &amp;= \sum_{\pmb{x},\pmb{y}} \left[ \tilde{P}(\pmb{x},\pmb{y}) \sum_{k=1}^K w_k f_k (\pmb{y},\pmb{x}) - \tilde{P}(\pmb{x},\pmb{y}) \log Z_{\pmb{w}} (\pmb{x}) \right] \nonumber \\
    &amp;= \sum_{j=1}^N \sum_{k=1}^K w_k f_k(\pmb{y}_j,\pmb{x}_j) - \sum_{j=1}^N \log Z_{\pmb{w}} (\pmb{x}_j) \nonumber
\end{align}\]</span></p>
<p>改进的迭代尺度法通过迭代的方法不断优化对数似然函数改变量的下界，达到极大化对数似然函数的目的。假设模型的当前参数向量为<span class="math inline">\(\pmb{w} = (w_1,w_2,\cdots,w_K)^T\)</span>，向量的增量为<span class="math inline">\(\pmb{\delta} = (\delta_1,\delta_2,\cdots,\delta_K)^T\)</span>，更新参数向量为<span class="math inline">\(\pmb{w} + \pmb{\delta} = (w_1+\delta_1,w_2+\delta_2,\cdots,w_K+\delta_K)^T\)</span>。在每步迭代过程中，改进的迭代尺度法通过依次求解下述两个公式，得到<span class="math inline">\(\pmb{\delta} = (\delta_1,\delta_2,\cdots,\delta_K)^T\)</span>。</p>
<p>关于转移特征<span class="math inline">\(t_k\)</span>的更新方程为 <span class="math display">\[\begin{align}
    E_{\tilde{P}} [t_k] &amp;= \sum_{\pmb{x},\pmb{y}} \tilde{P} (\pmb{x},\pmb{y}) \sum_{i=1}^{n+1} t_k(y_{i-1},y_i,\pmb{x},i) \nonumber \\
    &amp;= \sum_{\pmb{x},\pmb{y}} \tilde{P}(\pmb{x}) P(\pmb{y}|\pmb{x}) \sum_{i=1}^{n+1} t_k(y_{i-1},y_i,\pmb{x},i) \exp(\delta_k T(\pmb{x},\pmb{y})) \nonumber \\
    &amp; \qquad k=1,2,\cdots,K_1 \tag{11.36}
\end{align}\]</span> 关于状态特征<span class="math inline">\(s_l\)</span>的更新方程为 <span class="math display">\[\begin{align}
    E_{\tilde{P}}[s_l] &amp;= \sum_{\pmb{x},\pmb{y}} \tilde{P}(\pmb{x},\pmb{y}) \sum_{i=1}^{n+1} s_l(y_i,\pmb{x},i) \nonumber \\
    &amp;= \sum_{\pmb{x},\pmb{y}} \tilde{P}(\pmb{x})P(\pmb{y}|\pmb{x})\sum_{i=1}^n s_l(y_i,\pmb{x},i) \exp(\delta_{K_1+l} T(\pmb{x},\pmb{y})) \nonumber \\
    &amp; \qquad l=1,2,\cdots,K_2 \tag{11.37} 
\end{align}\]</span> 式中<span class="math inline">\(T(\pmb{x},\pmb{y})\)</span>是在数据<span class="math inline">\((\pmb{x},\pmb{y})\)</span>中出现的所有特征数的总和： <span class="math display">\[T(\pmb{x},\pmb{y}) = \sum_k f_k(\pmb{y},\pmb{x}) = \sum_{k=1}^K \sum_{i=1}^{n+1} f_k(y_{i-1},y_i,\pmb{x},i) \tag{11.38}\]</span></p>
<p>算法如下： <img src="http://p35icynkw.bkt.clouddn.com/屏幕快照%202018-04-15%20下午7.27.34.png"></p>
<p><span class="math inline">\(T(\pmb{x},\pmb{y})\)</span>表示数据<span class="math inline">\((\pmb{x},\pmb{y})\)</span>中的特征总数，对不同的数据<span class="math inline">\((\pmb{x},\pmb{y})\)</span>取值可能不同。为了处理这个问题，定义松弛特征 <span class="math display">\[s(\pmb{x},\pmb{y}) = S - \sum_{i=1}^{n+1} \sum_{k=1}^K f_k(y_{i-1},y_i,\pmb{x},i)\]</span> 式中<span class="math inline">\(S\)</span>是一个常数，选择足够大的常数<span class="math inline">\(S\)</span>使得对训练数据集的所有数据<span class="math inline">\((\pmb{x},\pmb{y})\)</span>，<span class="math inline">\(s(\pmb{x},\pmb{y}) \geqslant 0\)</span>成立。这时特征总数可取<span class="math inline">\(S\)</span>。</p>
<p>由式（11.36）,对于转移特征<span class="math inline">\(t_k\)</span>，<span class="math inline">\(\delta_k\)</span>的更新方程是 <span class="math display">\[\begin{equation}
    \sum_{\pmb{x},\pmb{y}} \tilde{P}(\pmb{x}) P(\pmb{y}|\pmb{x}) \sum_{i=1}^{n+1} t_k(y_{i-1},y_i,\pmb{x},i) \exp(\delta_k S) = E_{\tilde{p}}[t_k] \nonumber \\
    \delta_k = \frac{1}{S} \log \frac{E_{\tilde{p}}[t_k]}{E_P[t_k]} \nonumber
\end{equation}\]</span><br>
其中， <span class="math display">\[E_P(t_k) = \sum_{\pmb{x}} \tilde{P} (\pmb{x}) \sum_{i=1}^{n+1} \sum_{y_{i-1},y_i} t_k(y_{i-1},y_i,\pmb{x},i) \frac{\alpha_{i-1}^T (y_{i-1}|\pmb{x}) M_i(y_{i-1},y_i|\pmb{x}) \beta_i(y_i|\pmb{x})}{Z(\pmb{x})}\]</span> 同样由式（11.37），对于状态特征<span class="math inline">\(s_l\)</span>，<span class="math inline">\(\delta_k\)</span>的更新方程是 <span class="math display">\[\begin{equation}
    \sum_{\pmb{x},\pmb{y}} \tilde{P}(\pmb{x}) P(\pmb{y}|\pmb{x}) \sum_{i=1}^n s_l (y_i,\pmb{x},i) \exp(\delta_{K_1+l}S) = E_{\tilde{P}}[s_l] \nonumber \\
    \delta_{K_1+l} = \frac{1}{S} \log \frac{E_{\tilde{P}}[s_l]}{E_P[s_l]} \nonumber
\end{equation}\]</span> 其中， <span class="math display">\[E_P(s_l) = \sum_{\pmb{x}} \tilde{P} (\pmb{x}) \sum_{i=1}^n \sum_{y_i} s_l (y_i,\pmb{x},i) \frac{\alpha_i^T (y_i|\pmb{x}) \beta_i (y_i|\pmb{x})}{Z(\pmb{x})}\]</span></p>
<p>以上算法称为算法S。在算法S中需要使常数S取足够大，这样一来，每步迭代的增量向量会变小，算法收敛会变慢。算法T试图解决这个问题。算法T对每个观测序列<span class="math inline">\(\pmb{x}\)</span>计算其特征总数最大值<span class="math inline">\(T(\pmb{x})\)</span>： <span class="math display">\[T(\pmb{x}) = \max_{\pmb{y}} T(\pmb{x},\pmb{y})\]</span> 利用前向-后向递推公式，可以很容易计算<span class="math inline">\(T(\pmb{x}) = t\)</span>。<br>
此时，关于转移特征参数的更新方程可以写成： <span class="math display">\[\begin{align}
    E_{\tilde{P}} [t_k] &amp;= \sum_{\pmb{x},\pmb{y}} \tilde{P}(\pmb{x}) P(\pmb{y}|\pmb{x}) \sum_{i=1}^{n+1} t_k(y_{i-1},y_i,\pmb{x},i) \exp(\delta_k T(\pmb{x})) \nonumber \\
    &amp;= \sum_{\pmb{x}} \tilde{P}(\pmb{x}) \sum_{\pmb{y}} P(\pmb{y}|\pmb{x}) \sum_{i=1}^{n+1} t_k(y_{i-1},y_i,\pmb{x},i) \exp(\delta_k T(\pmb{x})) \nonumber \\
    &amp;= \sum_{\pmb{x}} \tilde{P} (\pmb{x}) a_{k,t} \exp(\delta_k \cdot t) \nonumber \\
    &amp;= \sum_{t=0}^{T_{max}} a_{k,t} \beta_k^t \nonumber
\end{align}\]</span> 式中，<span class="math inline">\(a_{k,t}\)</span>是特征<span class="math inline">\(t_k\)</span>的期望值，<span class="math inline">\(\delta_k = \log \beta_k\)</span>。<span class="math inline">\(\beta_k\)</span>是上述多项式方程唯一的实根，可以用牛顿法求得，从而求得相关的<span class="math inline">\(\delta_k\)</span>。</p>
<p>同样，关于状态特征的函数更新方程可以写成： <span class="math display">\[\begin{align}
    E_{\tilde{P}} [t_k] &amp;= \sum_{\pmb{x},\pmb{y}} \tilde{P}(\pmb{x}) P(\pmb{y}|\pmb{x}) \sum_{i=1}^{n+1} s_l(y_i,\pmb{x},i) \exp(\delta_{K_1+l} T(\pmb{x})) \nonumber \\
    &amp;= \sum_{\pmb{x}} \tilde{P}(\pmb{x}) \sum_{\pmb{y}} P(\pmb{y}|\pmb{x}) \sum_{i=1}^{n+1} s_l(y_i,\pmb{x},i) \exp(\delta_{K_1+l} T(\pmb{x})) \nonumber \\
    &amp;= \sum_{\pmb{x}} \tilde{P} (\pmb{x}) b_{l,t} \exp(\delta_k \cdot t) \nonumber \\
    &amp;= \sum_{t=0}^{T_{max}} b_{l,t} \gamma_l^t \nonumber
\end{align}\]</span></p>
<p>上式中<span class="math inline">\(b_{l,t}\)</span>是特征<span class="math inline">\(s_l\)</span>的期望值，<span class="math inline">\(\delta_l = \log \gamma_l\)</span>，<span class="math inline">\(\gamma_l\)</span>是上述多项式方程唯一的实根，也可以用牛顿法求得。</p>
<h3 id="拟牛顿法">6.2. 拟牛顿法</h3>
<p>条件随机场模型学习还可以应用牛顿法或拟牛顿法。对于条件随机场模型 <span class="math display">\[P_{\pmb{w}} (\pmb{y}|\pmb{x}) = \frac{\exp \left( \sum_{i=1}^n w_i f_i(\pmb{x},\pmb{y}) \right)}{\sum_{\pmb{y}} \exp \left( \sum_{i=1}^n w_i f_i(\pmb{x},\pmb{y}) \right)}\]</span> 学习的优化目标函数是 <span class="math display">\[\min_{\pmb{w} \in \mathbf{R}^n} f(\pmb{w}) = \sum_{\pmb{x}} \tilde{P}(\pmb{x}) \log \sum_{\pmb{y}} \exp \left( \sum_{i=1}^n w_i f_i(\pmb{x},\pmb{y}) \right) - \sum_{\pmb{x},\pmb{y}} \tilde{P}(\pmb{x},\pmb{y}) \sum_{i=1}^n w_i f_i(\pmb{x},\pmb{y}) \]</span> 其梯度函数是 <span class="math display">\[g(\pmb{w}) = \sum_{\pmb{x},\pmb{y}} \tilde{P}(\pmb{x}) P_{\pmb{w}}(\pmb{y}|\pmb{x}) f(\pmb{x},\pmb{y}) - E_{\tilde{P}}(f)\]</span></p>
<p>BFGS算法如下： <img src="http://p35icynkw.bkt.clouddn.com/屏幕快照%202018-04-16%20下午4.31.19.png"></p>
<h2 id="预测算法">7. 预测算法</h2>
<p>条件随机场的预测问题是给定条件随机场<span class="math inline">\(P(Y|X)\)</span>和输入序列（观测序列）<span class="math inline">\(\pmb{x}\)</span>，求条件概率最大的输出序列（标记序列）<span class="math inline">\(\pmb{y}^*\)</span>，即对观测序列进行标注。条件随机场的预测算法是著名的维特比算法。</p>
<p>由式<span class="math inline">\(P_{\pmb{w}}(\pmb{y}|\pmb{x}) = \frac{\exp(\pmb{w} \cdot F(\pmb{y},\pmb{x}))}{Z_{\pmb{w}}(\pmb{x})}\)</span>可得： <span class="math display">\[\begin{align}
    \pmb{y}^* &amp;= \mathop{\arg \max}_{\pmb{y}} P_{\pmb{w}} (\pmb{y}|\pmb{x}) \nonumber \\
    &amp;= \mathop{\arg \max}_{\pmb{y}} \frac{\exp(\pmb{w} \cdot F(\pmb{y},\pmb{x}))}{Z_{\pmb{w}}(\pmb{x})} \nonumber \\
    &amp;= \mathop{\arg \max}_{\pmb{y}} \exp(\pmb{w} \cdot F(\pmb{y},\pmb{x})) \nonumber \\
    &amp;= \mathop{\arg \max}_{\pmb{y}} (\pmb{w} \cdot F(\pmb{y},\pmb{x})) \nonumber
\end{align}\]</span> 于是，条件随机场的预测问题称为非规范化概率最大的最优路径问题 <span class="math display">\[\max_{\pmb{y}} \quad (\pmb{w} \cdot F(\pmb{y},\pmb{x})) \tag{11.52}\]</span> 式中，路径表示标记序列，其中 <span class="math display">\[\begin{equation}
    \pmb{w} = (w_1,w_2,\cdots,w_K)^T \nonumber \\
    F(\pmb{y},\pmb{x}) = (f_1(\pmb{y},\pmb{x}),f_2(\pmb{y},\pmb{x}),\cdots,f_K(\pmb{y},\pmb{x}))^T \nonumber \\
    f_k(\pmb{y},\pmb{x}) = \sum_{i=1}^n f_k(y_{i-1},y_i,\pmb{x},i), \quad k=1,2,\cdots,K \nonumber
\end{equation}\]</span></p>
<p>注意，此时只需计算非规范化概率，不必计算准确的概率，这样可以大大提高效率。为了求解最优路径，将式（11.52）写成如下形式： <span class="math display">\[\max_{\pmb{y}} \quad \sum_{i=1}^n \pmb{w} \cdot F_i(y_{i-1},y_i,\pmb{x})\]</span> 其中 <span class="math display">\[F_i(y_{i-1},y_i,\pmb{x}) = (f_1(y_{i-1},y_i,\pmb{x},i),f_2(y_{i-1},y_i,\pmb{x},i),\cdots,f_K(y_{i-1},y_i,\pmb{x},i))^T\]</span> 是局部特征变量。</p>
<p><strong>维特比算法</strong>：<br>
首先求出位置1的各个标记<span class="math inline">\(j=1,2,\cdots,m\)</span>的非规范化概率： <span class="math display">\[\delta_1(j) = \pmb{w} \cdot F_1(y_0 = start, y_1= j,\pmb{x}), \quad j=1,2,\cdots,m\]</span> 一般的，由递推公式，求出位置<span class="math inline">\(i\)</span>的各个标记<span class="math inline">\(l=1,2,\cdots,m\)</span>的非规范化概率的最大值，同时记录非规范化概率最大值的路径 <span class="math display">\[\begin{equation}
    \delta_i(l) = \max_{1 \leqslant j \leqslant m} \{ \delta_{i-1}(j) + \pmb{w} \cdot F_i(y_{i-1}=j,y_i = l, \pmb{x}) \}, \quad l=1,2,\cdots,m \nonumber \\
    \Psi(l) = \mathop{\arg \max}_{1 \leqslant j \leqslant m} \{ \delta_{i-1}(j) + \pmb{w} \cdot F_i(y_{i-1} = j, y_i = l, \pmb{x}) \}, \quad l=1,2,\cdots,m \nonumber
\end{equation}\]</span> 直到<span class="math inline">\(i=n\)</span>时终止。这时求得非规范化概率的最大值为 <span class="math display">\[\max_{\pmb{y}}(\pmb{w} \cdot F(\pmb{y},\pmb{x})) = \max_{1 \leqslant j \leqslant m} \delta_n(j)\]</span> 即最优路径的终点 <span class="math display">\[y_n^* = \mathop{\arg \max}_{1 \leqslant j \leqslant m} \delta_n(j)\]</span> 由此最优路径终点返回， <span class="math display">\[y_i^* = \Psi_{i+1} (y_{i+1}^*), \quad i = n-1,n-2,\cdots,1\]</span> 求得最优路径<span class="math inline">\(\pmb{y}^* = (y_1^*,y_2^*,\cdots,y_n^*)^T\)</span>。<br>
综上得到条件随机场预测的维特比算法。</p>
<div class="figure">
<img src="http://p35icynkw.bkt.clouddn.com/屏幕快照%202018-04-16%20下午5.22.40.png">

</div>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/机器学习/" rel="tag"># 机器学习</a>
          
            <a href="/tags/概率图模型/" rel="tag"># 概率图模型</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/04/15/机器学习/牛顿法和拟牛顿法/" rel="next" title="牛顿法和拟牛顿法">
                <i class="fa fa-chevron-left"></i> 牛顿法和拟牛顿法
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/05/17/碎碎/指数分布/" rel="prev" title="指数分布">
                指数分布 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Daftar Isi
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Ikhtisar
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">silen Zhou</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">47</span>
                    <span class="site-state-item-name">posting</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#条件随机场"><span class="nav-number">1.</span> <span class="nav-text">条件随机场</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#定义"><span class="nav-number">1.1.</span> <span class="nav-text">1. 定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参数化形式"><span class="nav-number">1.2.</span> <span class="nav-text">2. 参数化形式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简化形式"><span class="nav-number">1.3.</span> <span class="nav-text">3. 简化形式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#矩阵形式"><span class="nav-number">1.4.</span> <span class="nav-text">4. 矩阵形式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#概率计算问题"><span class="nav-number">1.5.</span> <span class="nav-text">5. 概率计算问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#前向-后向算法"><span class="nav-number">1.5.1.</span> <span class="nav-text">5.1. 前向-后向算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#概率计算"><span class="nav-number">1.5.2.</span> <span class="nav-text">5.2. 概率计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#期望值计算"><span class="nav-number">1.5.3.</span> <span class="nav-text">5.3. 期望值计算</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#学习算法"><span class="nav-number">1.6.</span> <span class="nav-text">6. 学习算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#改进的迭代尺度法"><span class="nav-number">1.6.1.</span> <span class="nav-text">6.1. 改进的迭代尺度法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拟牛顿法"><span class="nav-number">1.6.2.</span> <span class="nav-text">6.2. 拟牛顿法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#预测算法"><span class="nav-number">1.7.</span> <span class="nav-text">7. 预测算法</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">silen Zhou</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Tema &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.0.2</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.0.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.0.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.2"></script>



  



	





  





  










  





  

  

  

  
  

  
  

  
    
      <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->

    
  


  
  

  

  

  

  

</body>
</html>
